/*
 内存管理
 - 更OC一样，Swift也是采取基于引用计数的ARC内存管理方案（针对堆空间）
 - Swift的ARC中有3种引用：
    - 强引用（strong reference）：默认情况下，引用都是强引用
    - 弱引用（weak reference）：通过 weak 定义弱引用
        - 必须是 可选类型 的 var，因为实例销毁后，ARC会自动将弱引用设置为nil
        - ARC自动给弱引用设置nil时，不会触发属性观察器
    - 无主引用（unowned reference）：通过 unowned 定义无主引用
        - 不会产生强引用，实例销毁后仍然存储着实例的内存地址（类似于OC中的 unsafe_unretained）
        - 试图在实例销毁后访问无主引用，会产生运行时错误（野指针）
 
 weak、unowned的使用限制
    - 只能用在 类实例 上面
 
 循环引用
    - weak、unowned都能解决循环引用的问题，unowned比weak少一些性能消耗
        - 在生命周期中可能会变成nil的使用weak
        - 初始化赋值后再也不会变为nil的使用unowned
 
 闭包的循环引用
    - 闭包表达式默认会对用到的外层对象产生额外的强引用（对外层对象进行了retain操作）
    - 在闭包表达式的[捕获列表]声明weak或unowned引用，解决循环引用问题
    - 如果lazy属性是闭包调用的结果，那么不用考虑循环引用的问题（因为闭包调用后，闭包的生命周期就结束了）
 
 @escaping
    - 非逃逸闭包：闭包调用发生在函数结束前，闭包调用在函数作用域内
    - 逃逸闭包：闭包【有可能】在函数结束后调用，闭包调用逃离了函数的作用域，需要通过 @escaping 声明
        - 逃逸闭包【不能捕获】inout参数
 */
