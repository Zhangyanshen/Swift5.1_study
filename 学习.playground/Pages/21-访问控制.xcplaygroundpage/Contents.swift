/*
 访问控制（Access Control）
 - Swift提供了5个不同的访问级别（以下是从高到低排列，实体指被访问级别修饰的内容）
    - open：允许在定义实体的模块、其他模块中访问，允许其他模块进行继承、重写（open只能用在类、类成员上）
    - public：允许在定义实体的模块、其他模块中访问，不允许其他模块进行继承、重写
    - internal：只允许在定义实体的模块中访问，不允许在其他模块中访问
    - fileprivate：只允许在定义实体的源文件中访问
    - private：只允许在定义实体的封闭声明中访问
 - 绝大部分 默认是 internal
 
 - 访问级别的使用准则：
    - 一个实体不可以被更低访问级别的实体定义
 - 元组类型：
    - 元组类型的访问级别是所有成员类型最低的那个
 - 泛型类型：
    - 泛型类型的访问级别是 类型的访问级别 以及 所有泛型类型参数的访问级别 中 最低 的那个
 - getter、setter
    - getter、setter默认自动接收它们所属环境的访问级别
    - 可以给setter单独设置一个比getter更低的访问级别，用以限制写权限
 - 初始化器
    - 如果一个public类想在另一个模块调用编译器生成的默认无参初始化器，必须显示提供public的无参初始化器
        - 因为public类的默认初始化器是internal级别
    - required初始化器必须跟它所属类拥有相同的访问级别
    - 如果结构体有private\fileprivate的存储实例属性，那么它的成员初始化器也是private\fileprivate
        - 否则，默认是internal
 - 枚举
    - 不能给enum的每个case单独设置访问级别
    - 每个case自动接收enum的访问级别
        - public enum定义的case也是public
 - 协议
    - 协议中定义的要求自动接收协议的访问级别，不能单独设置访问级别
        - public协议定义的要求也是public
    - 协议实现的访问级别 >= min(类型的访问级别，协议的访问级别)
 - 扩展
    - 如果有显示设置扩展的访问级别，扩展添加的成员自动接收扩展的访问级别
    - 如果没有显示设置扩展的访问级别，扩展添加的成员的默认访问级别，跟直接在类型中定义的成员一样
    - 可以单独给扩展添加的成员设置访问级别
    - 不能给用于遵守协议的扩展显示设置扩展的访问级别
 */
